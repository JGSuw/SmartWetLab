## javaParameterTemplate.vm
	
/*
 *
 * This file was generated by LLRP Code Generator 
 * see http://llrp-toolkit.cvs.sourceforge.net/llrp-toolkit/
 * for more information
 * Generated on: $utility.getDateNTime(); 
 *
 */

/*
 * Copyright 2007 ETH Zurich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 *
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 */

package org.llrp.ltk.generated.parameters;

	
## some strings we need
#set($encode = ".encodeBinary()")
#set($encodeXML = ".encodeXML")	
#set($list = "List")
#set($length = ".length()")
#set($lengthField = ".length")
#set($resName = "reserved")
#set($resType = "BitList")
#set($typeNum = ".TYPENUM")
#set($subtypeNr = "getParameterSubtype()")
#set($add = ".add")
#set($emptyBrack = "()")
#set($getClassName = ".getClass().getSimpleName()")

##set the class names here
#set ($parameterReference = "ParameterReference")
#set ($choiceReference = "ChoiceReference")
#set ($parameterDefinition = "ParameterDefinition")
#set ($choiceDefinition = "ChoiceDefinition")
#set ($reservedDefinition = "ReservedDefinition")
#set ($fieldDefinition = "FieldDefinition")
#set ($mustListRepeat = "1-N")
#set ($exactlyOnceRepeat = "1")
#set ($optionalRepeat = "0-1")
#set ($optionalListRepeat = "0-N")
#set($ns = "NAMESPACE")
	
	
##imports
## must clear the helper set
$utility.clearImports()
## some imports are always needed
## remember imports to avoid importing twice the same

	import java.util.LinkedList;
	$utility.addImport("LinkedList")
	import java.util.List;
	$utility.addImport("List")
	import org.apache.log4j.Logger;
	$utility.addImport("LOGGER")
	
	
	import org.jdom.Document;
	$utility.addImport("document")
	import org.jdom.Element;
	$utility.addImport("element")
	import org.jdom.Content;
	$utility.addImport("content")
	import org.jdom.Namespace;
	$utility.addImport("Namespace")
	
	import org.llrp.ltk.types.LLRPBitList;
	$utility.addImport("LLRPBitList")
	import org.llrp.ltk.types.LLRPMessage;
	$utility.addImport("LLRPMessage")
	import org.llrp.ltk.types.SignedShort;
	$utility.addImport("SignedShort")
	import org.llrp.ltk.types.UnsignedShort;
	$utility.addImport("UnsignedShort")
	
	import org.llrp.ltk.exceptions.InvalidLLRPMessageException;
	$utility.addImport("InvalidLLRPMessageException")
	import org.llrp.ltk.exceptions.MissingParameterException;
	$utility.addImport("MissingParameterException")
	import org.llrp.ltk.types.TLVParameter;
	$utility.addImport("TLVParameter")
	import org.llrp.ltk.types.TVParameter;
	$utility.addImport("TVParameter")
import org.llrp.ltk.generated.LLRPConstants;
	$utility.addImport("LLRPConstants")
	
	
	##custom parameters
	#foreach ($custom in $utility.allowedCustom($parameter.getName()))
	import org.llrp.ltk.generated.custom.parameters.$custom;
	$utility.addImport($custom)
	#end
	
	## field or reserved
	#foreach($field in $parameter.getFieldOrReserved())
		## reserved field
		#if ($utility.hasType($field,$reservedDefinition))
			#if (!$utility.hasImport($resType))
				import org.llrp.ltk.types.$resType;
				$utility.addImport($resType)
			#end
		#elseif ($utility.hasType($field,$fieldDefinition))
			## its a field and therefore it might be also an enumeration
			## only place where we can find super types of enumerations
			## distinguish between custom and normal enumerations
			#if ($field.getEnumeration() && !$utility.isCustomEnumeration($field.getEnumeration()))
				
				#if ($utility.isArray($utility.convertType($field.getType().value())))
					#set ($arr = "Array")
					#set ($type = "$field.getEnumeration()")
					#set ($together = "$type$arr")
					#if (!$utility.hasImport($together))
						$utility.setSuperType($together,$field.getType().value())
						$utility.addImport($together)
						import org.llrp.ltk.generated.enumerations.$together;
					#end
				#else
					#if (!$utility.hasImport($field.getEnumeration()))
						$utility.setSuperType($field.getEnumeration(),$field.getType().value())
						import org.llrp.ltk.generated.enumerations.$field.getEnumeration();
						$utility.addImport($field.getEnumeration())
					#end
				#end
			#elseif ($field.getEnumeration() && $utility.isCustomEnumeration($field.getEnumeration()))
				
				
				#if ($utility.isArray($utility.convertType($field.getType().value())))
					#set ($arr = "Array")
					#set ($type = "$field.getEnumeration()")
					#set ($together = "$type$arr")
					#if (!$utility.hasImport($together))
						$utility.setSuperType($together,$field.getType())
						$utility.addImport($together)
						import org.llrp.ltk.generated.custom.enumerations.$together;
					#end
				#else
					#if (!$utility.hasImport($field.getEnumeration()))
						$utility.setSuperType($field.getEnumeration(),$field.getType().value())
						import org.llrp.ltk.generated.custom.enumerations.$field.getEnumeration();
						$utility.addImport($field.getEnumeration())
					#end
				#end
			#elseif ($field.getFormat())
				#set ($firstF = "$utility.convertType($field.getType().value())")
				#set ($secondF = "_")
				#set ($thirdF = "$field.getFormat()")
				#set ($together = "$firstF$secondF$thirdF")
				#if (!$utility.hasImport($together))
					import org.llrp.ltk.types.$together;
					$utility.addImport($together)
				#end
			#elseif (!$utility.hasImport($utility.convertType($field.getType().value())))
				import org.llrp.ltk.types.$utility.convertType($field.getType().value());
				$utility.addImport($utility.convertType($field.getType().value()))
			#end
		## FieldDefinition
		#else
					//TODO 1 template wrote this - unexpected object $field
		#end	
	#end
	
	
	## parameter or choice
	#foreach($field in $parameter.getParameterOrChoice())
		##for choices we must also import implementing classes
		#if ($utility.hasType($field,$choiceReference))
			##check all subtypes
			#foreach ($subtype in $utility.getSubTypes($field.getType()))
				#if ($utility.isCustomParameter($subtype))
					import org.llrp.ltk.generated.custom.parameters.$subtype;
				#else
					import org.llrp.ltk.generated.parameters.$subtype;
				#end				
				$utility.addImport($subtype)
			#end
			#if ($utility.isCustomChoice($field.getType()))
				import org.llrp.ltk.generated.custom.interfaces.$field.getType();
				$utility.addImport($field.getType())
			#else 
				import org.llrp.ltk.generated.interfaces.$field.getType();
				$utility.addImport($field.getType())
			#end
		#else
			#if (!$utility.hasImport($field.getType()))
				#if ($utility.isCustomParameter($field.getType()))
					import org.llrp.ltk.generated.custom.parameters.$field.getType();
				#else
					import org.llrp.ltk.generated.parameters.$field.getType();
				#end
				$utility.addImport($field.getType())
			#end
		#end
	#end
	
	##import interfaces to implement
	#foreach ($interface in $utility.getInterfaces($parameter.getName()))
	
			#if ($utility.isCustomChoice($interface))
				import org.llrp.ltk.generated.custom.interfaces.$interface;
				$utility.addImport($interface)
			#else 
				import org.llrp.ltk.generated.interfaces.$interface;
				$utility.addImport($interface)
			#end
	#end
	
	#foreach ($custom in $utility.allowedCustom($parameter.getName()))
	import org.llrp.ltk.generated.custom.parameters.$custom;
	$utility.addImport($custom)
	#end
##end imports
	
	
		
/**
 * $utility.getAnnotation($parameter)
 */
 
## TV Parameters have type number from 0 - 127, TLV from 128 - 2047
#if ($parameter.getTypeNum() < 128)
	#set ($superType = "TVParameter")
#else
	#set ($superType = "TLVParameter")
#end

##set interfaces
#set ($interfaces = "")
#set ($first = true)
#foreach ($interface in $utility.getInterfaces($parameter.getName()))
	#if ($first)
		#set ($interfaces = "implements $interface")
		#set ($first = false)
	#else
		#set ($interfaces = "$interfaces, $interface")
	#end
#end


/**
 * $utility.getAnnotation($parameter).
 */
## beginning of class
public class $parameter.Name extends $superType $interfaces{						

##TYPENUM is always needed
	public static final SignedShort TYPENUM = new SignedShort($parameter.getTypeNum());
##need always a LOGGER
	#set($class = ".class")
	private static final Logger LOGGER = Logger.getLogger($parameter.Name$class);
	
	
## field or reserved
#foreach($field in $parameter.getFieldOrReserved())
	## reserved field
	#if ($utility.hasType($field,$reservedDefinition))
		protected $resType $resName$utility.getCurrentNumerOfReserved() = new $resType ($field.getBitCount());
	#elseif ($utility.hasType($field,$fieldDefinition))
		#if ($field.getEnumeration())
				#if ($utility.isArray($utility.convertType($field.getType().value())))
					#set ($arr = "Array")
				#else
					#set ($arr = "")
				#end
			protected $field.getEnumeration()$arr $utility.firstToLowerCase($field.getName());
		#elseif ($field.getFormat())
			#set ($firstF = "$utility.convertType($field.getType().value())")
			#set ($secondF = "_")
			#set ($thirdF = "$field.getFormat()")
			protected $firstF$secondF$thirdF $utility.firstToLowerCase($field.getName()); 
		#else
			protected $utility.convertType($field.getType().value()) $utility.firstToLowerCase($field.getName());
		#end
	## FieldDefinition
	#else
				//TODO 2 template wrote this - unexpected object $field
	#end	
#end

##must clear numbers of reserved definitons found
$utility.clearNumberOfReserved()

## parameter or choice
#foreach($field in $parameter.getParameterOrChoice())
	## parameters usually don't have names, so the variable gets the type with first letter to lower case as name
	## however there are some exceptions to this where there is a name given

	#if ($field.getName())
		#set ($curName = $utility.firstToLowerCase($field.getName()))
	#else
		#set ($curName = $utility.firstToLowerCase($field.getType()))
	#end 	
	
	#if ($field.getRepeat() == $mustListRepeat || $field.getRepeat() == $optionalListRepeat)
		protected List<$field.getType()> $curName$list = new LinkedList<$field.getType()>();
	#else
		protected $field.getType() $curName;
	#end
#end


## constructor
		
/**
 * empty constructor to create new parameter.
 */
	public $parameter.getName()(){
	}

/**
 * Constructor to create parameter from binary encoded parameter
 * calls decodeBinary to decode parameter.
 * @param list to be decoded
 */
	public $parameter.getName()(LLRPBitList list){
		decodeBinary(list);
	}

	
	/**
 * Constructor to create parameter from xml encoded parameter
 * calls decodeXML to decode parameter.
 * @param element to be decoded
 */	
	public $parameter.getName()(Element element)  throws InvalidLLRPMessageException {
		decodeXML(element);
	}
	
## encode method
		/**
	 * {@inheritDoc}
	 */
	public LLRPBitList encodeBinarySpecific(){
	LLRPBitList resultBits = new LLRPBitList();
	## field or reserved
	#foreach($field in $parameter.getFieldOrReserved())
		#if ($utility.hasType($field,$reservedDefinition))
			resultBits.append($resName$utility.getCurrentNumerOfReserved()$encode);
		#elseif ($utility.hasType($field,$fieldDefinition))
			if ($utility.firstToLowerCase($field.getName())== null){
				LOGGER.warn(" $utility.firstToLowerCase($field.getName()) not set");
				throw new MissingParameterException(" $utility.firstToLowerCase($field.getName()) not set  for Parameter of Type $parameter.getName()");
			} 
			resultBits.append($utility.firstToLowerCase($field.getName())$encode);
		## FieldDefinition
		#else
			//TODO 3 template parameter encode wrote this - unexpected object $field
		#end
	#end
	## parameter or choice
	#foreach($field in $parameter.getParameterOrChoice())
		## parameters usually don't have names, so the variable gets the type with first letter to lower case as name
		## however there are some exceptions to this where there is a name given

		#if ($field.getName())
			#set ($curName = $utility.firstToLowerCase($field.getName()))
		#else
			#set ($curName = $utility.firstToLowerCase($field.getType()))
		#end
		## check if it is a list 	
		#if ($field.getRepeat()==$mustListRepeat)
			if ($curName$list== null){
				LOGGER.warn(" $curName$list not set");
				//parameter has to be set - throw exception
				throw new MissingParameterException(" $curName$list not set");
			} else {
				for ($field.Type field : $curName$list){
					resultBits.append(field$encode);
				}
			}
		#elseif ($field.getRepeat()==$optionalListRepeat)
			if ($curName$list== null){
				//just warn - it is optional 
				LOGGER.info(" $curName$list not set");
			} else {
				for ($field.Type field : $curName$list){
					resultBits.append(field$encode);
				}
			}
		#elseif ($field.getRepeat()==$exactlyOnceRepeat)
			if ($curName == null){
				// single parameter, may not be null
				LOGGER.warn(" $curName not set");
				throw new MissingParameterException(" $curName not set");
			} else {
				resultBits.append($curName$encode);
			}
		#elseif ($field.getRepeat()==$optionalRepeat)
			if ($curName == null){
				// optional parameter, may be null
				LOGGER.info(" $curName not set");
			} else {
				resultBits.append($curName$encode);
			}
				 
		#else
			// TODO field.getRepeat = $field.getRepeat() not handled
		#end
	#end
		return resultBits;
	}

##must clear numbers of reserved definitons found
$utility.clearNumberOfReserved()

## encode xml
		/**
	 * {@inheritDoc}
	 */
	public Content encodeXML(String name, Namespace ns){
		#set($ns = "NAMESPACE")
		// element in namespace defined by parent element
        Element element = new Element(name, ns);
        // child element are always in default LLRP namespace
    	ns = Namespace.getNamespace("llrp",LLRPConstants.LLRPNAMESPACE);
    	
		## field or reserved
		#foreach($field in $parameter.getFieldOrReserved())
			#if ($utility.hasType($field,$reservedDefinition))
				//element.addContent($resName$utility.getCurrentNumerOfReserved()$encodeXML("reserved",ns));
			#elseif ($utility.hasType($field,$fieldDefinition))
				## FieldDefinition
				if ($utility.firstToLowerCase($field.getName())== null){
					LOGGER.warn(" $utility.firstToLowerCase($field.getName()) not set");
					throw new MissingParameterException(" $utility.firstToLowerCase($field.getName()) not set");
				} else {
					element.addContent($utility.firstToLowerCase($field.getName())$encodeXML("$field.getName()",ns));
				}
			#else
				//TODO 4 template parameter encode wrote this - unexpected object $field $field.getName()
			#end
		#end
		## parameter or choice
		//parameters
		#foreach($field in $parameter.getParameterOrChoice())
			## parameters usually don't have names, so the variable gets the type with first letter to lower case as name
			## however there are some exceptions to this where there is a name given
	
			#if ($field.getName())
				#set ($curName = $utility.firstToLowerCase($field.getName()))
			#else
				#set ($curName = $utility.firstToLowerCase($field.getType()))
			#end
			## check if it is a list 	
			#if ($field.getRepeat()==$mustListRepeat)
				if ($curName$list== null){
					LOGGER.warn(" $curName$list not set");
					throw new MissingParameterException("  $curName$list not set");
				} 
				for ($field.getType() field : $curName$list){
					##choices have to be set by the actual name - not the name of the interface
					element.addContent(field$encodeXML(field.getClass().getName().replaceAll(field.getClass().getPackage().getName()+".", ""),ns));
				}
			#elseif ($field.getRepeat()== $optionalListRepeat)
				if ($curName$list == null){
					LOGGER.info("$curName$list not set");
				} else {
					for ($field.getType() field : $curName$list){
						element.addContent(field$encodeXML(field.getClass().getName().replaceAll(field.getClass().getPackage().getName()+".", ""),ns));
					}
				}
			#elseif ($field.getRepeat()== $optionalRepeat)
				if ($curName == null){
					LOGGER.info("$curName not set");
				} else {
					#if ($field.getName())
							// name was defined for this parameter - must use it to avoid confusion with parameters of same type
							element.addContent($curName$encodeXML("$curName",ns));
					#else
							element.addContent($curName$encodeXML($curName$getClassName,ns));
					#end
				}
			#elseif ($field.getRepeat()== $exactlyOnceRepeat)
				if ($curName == null){
					LOGGER.info("$curName not set");
					throw new MissingParameterException("$curName not set");
				} else {
					#if ($field.getName())
							// name was defined for this parameter - must use it to avoid confusion with parameters of same type
							element.addContent($curName$encodeXML("$curName",ns));
					#else
							element.addContent($curName$encodeXML($curName$getClassName,ns));
					#end					
				}
			#else
				// TODO field.getRepeat() = $field.getRepeat()
			#end
		#end
		return element;
	}

##must clear numbers of reserved definitons found
$utility.clearNumberOfReserved()	
	
##decode
  
		/**
	 * {@inheritDoc}
	 */
	protected void decodeBinarySpecific(LLRPBitList binary){
		int position = 0;
		int tempByteLength;
		int tempLength=0;
		int count;
		SignedShort type;
		int fieldCount;
		Custom custom;
		## field or reserved
		#foreach($field in $parameter.getFieldOrReserved())
			## reserved field
			#if ($utility.hasType($field,$reservedDefinition))
				position+= $resName$utility.getCurrentNumerOfReserved()$length;
			#elseif ($utility.hasType($field,$fieldDefinition))
				#set ($curName = $utility.firstToLowerCase($field.getName()))
				#if ($field.getEnumeration())
					#set ($curType = $field.getEnumeration())	#if ($utility.isArray($utility.convertType($field.getType().value())))
						#set ($arr = "Array")
						#set ($temp = "$utility.firstToUpperCase($field.getEnumeration())")
						#set ($curType = "$temp$arr")
					#else
						#set ($curType = $utility.firstToUpperCase($field.getEnumeration()))
					#end
				#elseif ($field.getFormat())
					#set ($firstF = "$utility.convertType($field.getType().value())")
					#set ($secondF = "_")
					#set ($thirdF = "$field.getFormat()")
					#set ($curType ="$firstF$secondF$thirdF")
				#else					
					#set ($curType = $utility.convertType($field.getType().value()))
				#end
				#if ($utility.isArray($curType))
					// array. first 16 bits indicate length of array
					fieldCount = new UnsignedShort(binary.subList(position, UnsignedShort.length())).toShort();			
					tempLength=$curType$length*fieldCount+UnsignedShort.length();
					$curName = new $curType (binary.subList(position, tempLength));
					position += tempLength;
					LOGGER.debug("decoding array of type: $curType with "+tempLength+" length");
					//might need padding
					// must always be blocks of 8 bites, if it is a bitlist, this might not be automatically the case
					if (tempLength%8>0){
						position+=(8-tempLength%8);
						LOGGER.info("padding needed for $curName ");
					} 
				#elseif ($utility.isByteToEnd($curType))
					$curName = new $curType (binary.subList(position, binary.length()-position));
					position += binary.length()-position;

				#else
					$curName = new $curType (binary.subList(position, $curType$length));
					position += $curType$length;
				#end
			#else
						//TODO 5 template wrote this - unexpected object $field
			#end
		#end  
		
		
		## parameter or choice
		#foreach($field in $parameter.getParameterOrChoice())
		## get name first, not all have a name attribute
		#if ($field.getName())
			#set ($curName = $utility.firstToLowerCase($field.getName()))
		#else
			#set ($curName = $utility.firstToLowerCase($field.getType()))
		#end
		## check if it is a list 	
		#if ($field.getRepeat()==$mustListRepeat  || $field.getRepeat()== $optionalListRepeat)
			// list of parameters
			$curName$list = new LinkedList<$field.getType()>();
			LOGGER.debug("decoding parameter $curName$list ");
			while (position < binary.length()){
				// store if one parameter matched
				boolean atLeastOnce = false;
				// look ahead to see type
				if (binary.get(position)){
					// do not take the first bit as it is always 1
        			type = new SignedShort(binary.subList(position+1, 7));
				} else {
					type = new SignedShort(binary.subList(position+RESERVEDLENGTH, TYPENUMBERLENGTH));
					tempByteLength = new UnsignedShort(binary.subList(position+RESERVEDLENGTH+ TYPENUMBERLENGTH, UnsignedShort.length())).toShort();			
					tempLength=8*tempByteLength;
				}
				
				##distinguish between choices and parameters. For choices, we must find the actual types
				#if ($utility.hasType($field,$choiceReference))
					//choiceRef
					##check all subtypes
					#foreach ($subtype in $utility.getSubTypes($field.getType()))
						#if ($utility.isCustom($subtype))
							## custom parameter need separate treatment
							// custom
							if(type != null && type.equals(Custom$typeNum)){
								Custom cus = new Custom(binary.subList(position,tempLength)); 
								// custom parameters for this parameter	
								#foreach ($custom in $utility.allowedCustom($parameter.getName()))
									if (cus.getParameterSubtype().equals(new $custom ().$subtypeNr)){ 
										$curName$list$add (new $custom (cus));
										LOGGER.debug("adding $custom to $curName$list ");	
										position+=tempLength;
										atLeastOnce = true;
										continue;
									}
								#end	
								//end  parameters
								//if none matched continue wasn't called and we add just cus as we found no specific vendor implementation
								$curName$list$add (cus);
								position+=tempLength;
								atLeastOnce = true;
							}
						#else						
							if (type != null && type.equals($subtype$typeNum)){
								if (binary.get(position)){
									// length can statically be determined for TV Parameters
        							tempLength = $subtype$length;
								} 
								$curName$list$add (new $subtype (binary.subList(position,tempLength)));
								LOGGER.debug("adding $subtype to $curName$list ");
								position+=tempLength;
								atLeastOnce = true;
							}
						#end
						
					#end
					
					
				#elseif ($utility.isCustom($field.getType()))
							## custom parameter need separate treatment
							// custom
						if(type != null && type.equals(Custom$typeNum)){
							Custom cus = new Custom(binary.subList(position,tempLength)); 
							// custom parameters for this parameter	
							// $parameter.getName()
							#foreach ($custom in $utility.allowedCustom($parameter.getName()))
								if (cus.getParameterSubtype().equals(new $custom ().$subtypeNr)){ 
									$curName$list$add (new $custom (cus));
									atLeastOnce = true;
									LOGGER.debug("adding $custom to $curName$list ");	
									position+=tempLength;
									atLeastOnce = true;
									continue;
								}
							#end	
							//end  parameters
							//if none matched continue wasn't called and we add just cus as we found no specific vendor implementation
							$curName$list$add (cus);
							position+=tempLength;
							atLeastOnce = true;
						}
				#elseif ($utility.hasType($field,$parameterReference))
					//add parameter to list if type number matches
					if (type != null && type.equals($field.getType()$typeNum)){
						if (binary.get(position)){
							// length can statically be determined for TV Parameters
	        				tempLength = $field.getType()$length;
						} 
						$curName$list$add (new $field.getType() (binary.subList(position,tempLength)));
						LOGGER.debug("adding $field.getType() to $curName$list ");
						atLeastOnce = true;	
						position+=tempLength;
					}
				#else
					//TODO 6 template wrote this in decode > list- unexpected object $field in while
				#end
				if (!atLeastOnce){
					//no parameter matched therefore we jump out of the loop
					break;
				}
			}
			#set($isEmpty = ".isEmpty()")
			#if ($field.getRepeat() == $mustListRepeat)
					//if list is still empty no parameter matched
					if ($curName$list$isEmpty){
						LOGGER.warn("encoded message does not contain parameter for non optional $curName$list");
						throw new MissingParameterException("$parameter.getName() misses non optional parameter of type $field.getType()");
					}
				#else
					//if list is still empty no parameter matched
					if ($curName$list$isEmpty){
						LOGGER.info("encoded message does not contain parameter for optional $curName$list");
						
					}
			#end
		#elseif ($field.getRepeat()==$exactlyOnceRepeat || $field.getRepeat() == $optionalRepeat)
			## single parameter - must be set 
			// look ahead to see type
			// may be optional or exactly once
			type = null;
			tempByteLength = 0;			
			tempLength=0;
			
			try {
				// if first bit is one it is a TV Parameter
				if (binary.get(position)){
					// do not take the first bit as it is always 1
        			type = new SignedShort(binary.subList(position+1, 7));
				} else {
					type = new SignedShort(binary.subList(position+RESERVEDLENGTH, TYPENUMBERLENGTH));
					tempByteLength = new UnsignedShort(binary.subList(position+RESERVEDLENGTH+ TYPENUMBERLENGTH, UnsignedShort.length())).toShort();			
					tempLength=8*tempByteLength;
				}
			
			} catch (IllegalArgumentException le) {
				// if an IllegalArgumentException is thrown, list was not long enough so the parameter is missing
				## throw exception only when single Parameter - if it is optinal it is okay that it is not set
				#if ( $field.getRepeat() == $exactlyOnceRepeat)
					LOGGER.warn("$parameter.getName() misses non optional parameter of type $field.getType()");
					throw new MissingParameterException("$parameter.getName() misses non optional parameter of type $field.getType()");
				#else
				##if it is optional, just inform that it is not set
					LOGGER.info("$parameter.getName() misses optional parameter of type $field.getType()");
				#end
			}
			##distinguish between choices and parameters. For choices, we must find the actual types
			#if ($utility.hasType($field,$choiceReference))
				##check all subtypes
				boolean found = false;
				LOGGER.debug("decoding choice type $field.getType() ");
				#foreach ($subtype in $utility.getSubTypes($field.getType()))
					//if first bit is 1 it is a TV Parameter
					
					if (binary.get(position)){
						// length can statically be determined for TV Parameters
        				tempLength = $subtype$length;
					} 
					#if ($utility.isCustom($subtype))
					## custom parameter need separate treatment
					// custom
						if(type != null && type.equals(Custom$typeNum)){
							Custom cus = new Custom(binary.subList(position,tempLength)); 
							// custom parameters for this parameter	
							#foreach ($custom in $utility.allowedCustom($parameter.getName()))
								if (cus.getParameterSubtype().equals(new $custom ().$subtypeNr)){ 
									$curName=new $custom (cus);
									atLeastOnce = true;
									LOGGER.debug("adding $custom to $curName$list ");	
									position+=tempLength;
									atLeastOnce = true;
									continue;
								}
							#end	
							//end  parameters
							//if none matched continue wasn't called and we add just use cus as custom parameter as we found no specific vendor implementation
							$curName =cus;
							position+=tempLength;
							found = true;
						}
					#else						
						if (type != null && type.equals($subtype$typeNum)){
							$curName = new $subtype (binary.subList(position,tempLength));
							LOGGER.debug(" $curName instatiated to $subtype with length "+tempLength);
							position += tempLength;
							found = true;
						}
					#end
				#end
				if (!found){
					#if ( $field.getRepeat() == $exactlyOnceRepeat)
						LOGGER.warn("encoded message misses non optional parameter $curName");
						throw new MissingParameterException("$parameter.getName() misses non optional parameter of type $field.getType()");
					#else	
						##if it is optional, just inform that it is not set
						LOGGER.info("encoded message misses optional parameter $curName");
					#end				
				}
			#elseif ($utility.isCustom($field.getType()))
			    if(type != null && type.equals(Custom$typeNum)){
					## custom parameter need separate treatment
					// custom
					Custom cus = new Custom(binary.subList(position,tempLength)); 
					// custom parameters for this parameter	
					#foreach ($custom in $utility.allowedCustom($parameter.getName()))
						if (cus.getParameterSubtype().equals(new $custom ().$subtypeNr)){ 
							$curName=new $custom (cus);
							atLeastOnce = true;
							position+=tempLength;
							continue;
						}
					#end	
					//end  parameters
					//if none matched continue wasn't called and we add just use cus as custom parameter as we found no specific vendor implementation
					if ($curName == null){
						$curName =cus;
						position+=tempLength;
						found = true;
					}
				}
				if (!found){
					#if ( $field.getRepeat() == $exactlyOnceRepeat)
						LOGGER.warn("$parameter.getName() misses non optional parameter of type $field.getType()");
						throw new MissingParameterException("$parameter.getName() misses non optional parameter of type $field.getType()");
					#else	
						##if it is optional, just inform that it is not set
						LOGGER.info("$parameter.getName() misses optional parameter of type $field.getType()");
					#end
				}				
			#elseif ($utility.hasType($field,$parameterReference))
				if (binary.get(position)){
					// length can statically be determined for TV Parameters
        			tempLength = $curName$length;
				} 
				if(type != null && type.equals($field.getType()$typeNum)){
					$curName = new $field.getType() (binary.subList(position,tempLength));	
					position+=tempLength;
					LOGGER.debug(" $curName is instantiated with $field.getType() with length"+tempLength);
				} else {
					## if it is an optional parameter it is ok to come to here. Therefor only print an error message if it is not optional
					#if ( $field.getRepeat() == $exactlyOnceRepeat)
						LOGGER.warn("$parameter.getName() misses non optional parameter of type $field.getType()");
						throw new MissingParameterException("$parameter.getName() misses non optional parameter of type $field.getType()");
					#else	
						##if it is optional, just inform that it is not set
						LOGGER.info("$parameter.getName() misses optional parameter of type $field.getType()");
					#end
				}	
			#end
		#else
			//TODO 7 template wrote this - unexpected object $field
		#end
	#end
  	}
  	
 
##must clear numbers of reserved definitons found
$utility.clearNumberOfReserved() 	
  	
  		
##decode XML
  
		/**
	 * {@inheritDoc}
	 */
	public void decodeXML(Element element)  throws InvalidLLRPMessageException {
		List<Element> tempList = null;
		boolean atLeastOnce = false;
        Custom custom;
		
		Element temp = null;
		// child element are always in default LLRP namespace
    	Namespace ns = Namespace.getNamespace(LLRPConstants.LLRPNAMESPACE);
		
		## field or reserved
		#foreach($field in $parameter.getFieldOrReserved())
			## reserved field
			#if ($utility.hasType($field,$reservedDefinition))
				## skip reserved
			#elseif ($utility.hasType($field,$fieldDefinition))
				#set ($curName = $utility.firstToLowerCase($field.getName()))
				#if ($field.getEnumeration())
					#if ($utility.isArray($utility.convertType($field.getType().value())))
						#set ($arr = "Array")
						#set ($temp = "$utility.firstToUpperCase($field.getEnumeration())")
						#set ($curType = "$temp$arr")
					#else
						#set ($curType = $utility.firstToUpperCase($field.getEnumeration()))
					#end
				#elseif ($field.getFormat())
					#set ($firstF = "$utility.convertType($field.getType().value())")
					#set ($secondF = "_")
					#set ($thirdF = "$field.getFormat()")
					#set ($curType ="$firstF$secondF$thirdF")
				#else
					#set ($curType = $utility.convertType($field.getType().value()))
				#end
				temp = element.getChild("$field.getName()",ns);
				if (temp != null){
					$curName = new $curType (temp);
				}
				element.removeChild("$field.getName()",ns);
			#else
						//TODO 8 template wrote this - unexpected object $field
			#end
		#end  
		
		
		## parameter or choice
		#foreach($field in $parameter.getParameterOrChoice())
			#if ($field.getName())
				#set ($curName = $utility.firstToLowerCase($field.getName()))
			#else
				#set ($curName = $utility.firstToLowerCase($field.getType()))
			#end
			#if ($utility.hasType($field,$parameterReference))
				//parameter - not choices - no special actions needed
				#if ($field.getRepeat()==$mustListRepeat  || $field.getRepeat()== $optionalListRepeat)
					//we expect a list of parameters
					$curName$list = new LinkedList<$field.getType()>();
					tempList = element.getChildren("$field.getType()",ns);
					#if ( $field.getRepeat() == $mustListRepeat)
						if (tempList == null || tempList.isEmpty() ){
							LOGGER.warn("$parameter.getName() misses non optional parameter of type $curName$list");
							throw new MissingParameterException("$parameter.getName() misses non optional parameter of type $curName$list");
					#else
						##if it is optional, just inform that it is not set
						if (tempList == null || tempList.isEmpty() ){
							LOGGER.info("$parameter.getName() misses optional parameter of type $curName$list");
					#end						
					} else {
						for (Element e : tempList){
							$curName$list$add (new $field.getType()(e));
							LOGGER.debug("adding $field.getType() to $curName$list ");			
						}	
					}
					element.removeChildren("$field.getType()",ns);	
					#if ($utility.isCustom($field.getType()))
						//custom parameter
						#foreach ($custom in $utility.allowedCustom($parameter.getName()))
						// $utility.getPrefixForParameter($custom)
							Namespace ns$custom = Namespace.getNamespace("$utility.getPrefixForParameter($custom)",LLRPConstants.$utility.getPrefixForParameter($custom).toUpperCase()$ns);
							tempList = element.getChildren("$custom",ns$custom);
							for (Element e: tempList){
								$curName$list$add (new $custom (e));
								LOGGER.debug("adding $custom to $curName$list ");
							}
							element.removeChildren("$custom",ns$custom);
						#end
						tempList = element.getChildren("Custom",ns);
				        for (Element e : tempList){
				        	$curName$list$add(new Custom(e));
				        	atLeastOnce = true;
				        	LOGGER.debug("adding custom parameter");
				        }
				        
				        element.removeChildren("Custom",ns);
				        
						//end custom
					#end				
				#else
					temp = element.getChild("$field.getType()",ns);
					#if ($utility.isCustom($field.getType()))
						// custom parameter may be null, check  types
						if (temp == null){
						//check  types
						#foreach ($custom in $utility.allowedCustom($parameter.getName()))
							// $utility.getPrefixForParameter($custom)
							Namespace ns$custom = Namespace.getNamespace("$utility.getPrefixForParameter($custom)",LLRPConstants.$utility.getPrefixForParameter($custom).toUpperCase()$ns);
							temp = element.getChild("$custom",ns$custom);
							if (temp != null){
								$curName =  new $custom (custom);
							}
							element.removeChild("$custom",ns$custom);
						#end
						}
						temp = element.getChild("Custom",ns);
						if (temp != null){
							$curName =  new Custom (custom);
						}
						element.removeChild("Custom",ns);
						// end custom
                    #end
                    if (temp != null){
                       $curName = new $field.getType()(temp);
                       LOGGER.info("setting parameter $curName for parameter $parameter.getName()");
                    }
                    if (temp == null){
                       #if ( $field.getRepeat() == $exactlyOnceRepeat)
                           LOGGER.warn("$parameter.getName() misses non optional parameter of type $curName");
                           throw new MissingParameterException("$parameter.getName() misses non optional parameter of type $curName");
                       #else
                           ##if it is optional, just inform that it is not set
                           LOGGER.info("$parameter.getName() misses optional parameter of type $curName");
                       #end
                    }
					element.removeChild("$field.getType()",ns);
               #end          				
			#elseif ($utility.hasType($field,$choiceReference))
				//choices - must check all possible subtypes
				#if ($field.getRepeat()==$mustListRepeat  || $field.getRepeat()== $optionalListRepeat)
					//list of Choice Type Parameter
					$curName$list = new LinkedList<$field.getType()>();
					// for each possible subtype get all childs
						##check all subtypes
						#foreach ($subtype in $utility.getSubTypes($field.getType()))
							#if ($utility.isCustom($subtype))
								## custom parameter need separate treatment
								// check for all custom parameters  for this parameter 
								#foreach ($custom in $utility.allowedCustom($curName.getName()))
									#set($hasAllowed = "true")
									// $utility.getPrefixForParameter($custom)
									Namespace ns$custom = Namespace.getNamespace("$utility.getPrefixForParameter($custom)",LLRPConstants.$utility.getPrefixForParameter($custom).toUpperCase()$ns);		
									tempList = element.getChildren("$custom",ns$custom);
									for (Element e: tempList){
										$curName$list$add (new $custom (e));
										atLeastOnce = true;
										LOGGER.debug("adding $custom to $curName$list ");
									}
									element.removeChildren("$custom",ns$custom);
								#end
								// check for regular custom parameter
								tempList = element.getChildren("Custom",ns);
								for (Element e: tempList){
									$curName$list$add (new Custom(e));
									LOGGER.debug("adding $field.getType() to $curName$list ");
								}
								element.removeChildren("Custom",ns);
									
								//end allowed parameters
							#else
								tempList = element.getChildren("$subtype",ns);
								for (Element e : tempList){
									$curName$list$add (new $subtype(e));
									LOGGER.debug("adding $subtype to $curName$list ");
									atLeastOnce = true;
								}
								element.removeChildren("$subtype",ns);
								
							#end
							
						#end
						if (!atLeastOnce){
							#if ( $field.getRepeat() == $mustListRepeat)
								LOGGER.warn("$parameter.getName() misses non optional parameter of type $curName$list");
								throw new MissingParameterException("$parameter.getName() misses non optional parameter of type $curName$list");
							#else
								LOGGER.info("$parameter.getName() misses optional parameter of type $curName$list");
							#end	
						}
						atLeastOnce = false;		
				#else
				
					##check all subtypes
					boolean found = false;
					LOGGER.debug("decoding choice type $field.getType() ");
					#foreach ($subtype in $utility.getSubTypes($field.getType()))
						#if ($utility.isCustom($subtype))
							## custom parameter need separate treatment
							// custom
							temp = element.getChild("$subtype",ns);
							if (temp != null){
								custom = new $field.getType() (temp));	
								#foreach ($custom in $utility.allowedCustom($field.getType()))
									if (temp.getName().equalsIgnoreCase("$custom")){ 
										$curName =new $custom (custom) ;
										LOGGER.debug(" $curName is instantiated with $custom ");
									}
								#end
							}
							element.removeChild("$subtype",ns);
						#else		
							// try to get child for each possible subtype
							temp = element.getChild("$subtype",ns);		
							if (temp != null){
								$curName = new $subtype (temp);
								LOGGER.debug(" $curName instatiated to $subtype with");
								found = true;
							} 
							element.removeChild("$subtype",ns);		
						#end
					#end
					if (!found){
						#if ( $field.getRepeat() == $mustListRepeat)
							LOGGER.warn("$parameter.getName() misses non optional parameter $curName$list");
							throw new MissingParameterException("$parameter.getName() misses non optional parameter of type $curName$list");
						#else
						##if it is optional, just inform that it is not set
							LOGGER.info("$parameter.getName() misses optional parameter of type $curName$list");
						#end	
					}				
				
				#end
			#else
				//TODO 9 template wrote this in decode > list- unexpected object $field in while
			#end	
		#end
		if (element.getChildren().size()>0){
			String message = "$parameter.getName() has unknown element "+((Element) element.getChildren().get(0)).getName();
			throw new InvalidLLRPMessageException(message);
		}
  	}
  	


 
   
   	
	
## generate setters 
	//setters
	## field or reserved
	#foreach($field in $parameter.getFieldOrReserved())
		## reserved field
		#if ($utility.hasType($field,$reservedDefinition))
			## nothing
		#elseif ($utility.hasType($field,$fieldDefinition))
		## FieldDefinition
			#if ($field.getEnumeration())
					#if ($utility.isArray($utility.convertType($field.getType().value())))
						#set ($arr = "Array")
						#set ($temp = "$utility.firstToUpperCase($field.getEnumeration())")
						#set ($curType = "$temp$arr")
					#else
						#set ($curType = $utility.firstToUpperCase($field.getEnumeration()))
					#end
				/**
				 * set $utility.firstToLowerCase($field.getName()) of type $curType .
				 * @param  $utility.firstToLowerCase($field.getName()) to be set
				 */
				public void set$field.getName()(final $curType  $utility.firstToLowerCase($field.getName())){
					this.$utility.firstToLowerCase($field.getName()) = $utility.firstToLowerCase($field.getName());
				}
			#elseif ($field.getFormat())
				#set ($firstF = "$utility.convertType($field.getType().value())")
				#set ($secondF = "_")
				#set ($thirdF = "$field.getFormat()")
				#set ($together = "$firstF$secondF$thirdF")
				/**
				 * set $utility.firstToLowerCase($field.getName()) of type $together .
				 * @param  $utility.firstToLowerCase($field.getName()) to be set
				 */
				public void set$field.getName()(final $together $utility.firstToLowerCase($field.getName())){
					this.$utility.firstToLowerCase($field.getName()) = $utility.firstToLowerCase($field.getName());
				}
			
			#else
				/**
				 * set   $utility.firstToLowerCase($field.getName()) of type $utility.convertType($field.getType().value()) .
				 * @param   $utility.firstToLowerCase($field.getName()) to be set
				 */
				public void set$field.getName()(final $utility.convertType($field.getType().value())  $utility.firstToLowerCase($field.getName())){
					this.$utility.firstToLowerCase($field.getName()) = $utility.firstToLowerCase($field.getName());
				}
			
			#end
			
		#else
					//TODO 11 template wrote this - unexpected object $field
		#end	
	#end


	## parameter or choice
	#foreach($field in $parameter.getParameterOrChoice())
		
		## parameters usually don't have names, so the variable gets the typ with first letter to lower case as name
		## however there are some exceptions to this where there is a name given
		#if ($field.getName())
			#set ($curName = $field.getName())
		#else
			#set ($curName = $utility.firstToLowerCase($field.getType()))
		#end 
		#if ($field.getRepeat()== $mustListRepeat  || $field.getRepeat()== $optionalListRepeat)
			/**
			 * set $curName$list of type  List &lt;$field.getType()>.
			 * @param  $curName$list to be set
			 */
			public void set$utility.firstToUpperCase($curName)$list (final List<$field.getType()> $curName$list) {
				this.$curName$list = $curName$list;
			}
				
		#else
			/**
			 * set $curName of type $field.getType().
			 * @param  $curName to be set
			 */
			public void set$utility.firstToUpperCase($curName) (final $field.getType() $curName)  {
				this.$curName = $curName;
			}
		#end
	#end
	// end setter
	
	## generate getters 
	//getters
	## field or reserved
	#foreach($field in $parameter.getFieldOrReserved())
		## reserved field
		#if ($utility.hasType($field,$reservedDefinition))
			## nothing
		#elseif ($utility.hasType($field,$fieldDefinition))
		## FieldDefinition
			#if ($field.getEnumeration())
					#if ($utility.isArray($utility.convertType($field.getType().value())))
						#set ($arr = "Array")
						#set ($temp = "$utility.firstToUpperCase($field.getEnumeration())")
						#set ($curType = "$temp$arr")
					#else
						#set ($curType = $utility.firstToUpperCase($field.getEnumeration()))
					#end
				/**
				 * get $utility.firstToLowerCase($field.getName()) of type $curType.
				 * @return  $curType
				 */
				public $curType get$field.getName()$emptyBrack{
					return $utility.firstToLowerCase($field.getName());
				}
			#elseif ($field.getFormat())
					#set ($firstF = "$utility.convertType($field.getType().value())")
					#set ($secondF = "_")
					#set ($thirdF = "$field.getFormat()")
					#set ($together = "$firstF$secondF$thirdF")
				/**
				 * get $utility.firstToLowerCase($field.getName()) of type  $together.
				 * @return  $together
				 */
				public  $together get$field.getName()$emptyBrack{
					return $utility.firstToLowerCase($field.getName());
				}
			
			#else
				/**
				 * get   $utility.firstToLowerCase($field.getName()) of type $utility.convertType($field.getType().value()).
				 * @return   type $utility.convertType($field.getType().value()) to be set
				 */
				public $utility.convertType($field.getType().value()) get$field.getName()$emptyBrack{
					return this.$utility.firstToLowerCase($field.getName());
				}
			#end
		#else
			//TODO template wrote this - unexpected object $field
		#end	
	#end


	## parameter or choice
	#foreach($field in $parameter.getParameterOrChoice())
		## parameters usually don't have names, so the variable gets the typ with first letter to lower case as name
		## however there are some exceptions to this where there is a name given
		#if ($field.getName())
			#set ($curName = $field.getName())
		#else
			#set ($curName = $utility.firstToLowerCase($field.getType()))
		#end 
		#if ($field.getRepeat()== $mustListRepeat  || $field.getRepeat()== $optionalListRepeat)
			/**
			 * get $curName$list of type List &lt;$field.getType()> .
			 * @return  List &lt;$field.getType()>
			 */
			public List<$field.getType()> get$utility.firstToUpperCase($curName)$list$emptyBrack {
				return $curName$list;
			}
				
		#else
			/**
			 * get $curName of type $field.getType() .
			 * @return  $field.getType()
			 */
			public $field.getType() get$utility.firstToUpperCase($curName)$emptyBrack  {
				return $curName;
			}
		#end
	#end
	// end getters
##end getters	
	

	
## add methods
	 //add methods
	## field or reserved
	#foreach($field in $parameter.getFieldOrReserved())
		## reserved field
		#if ($utility.hasType($field,$reservedDefinition))
			## nothing
		#elseif ($utility.hasType($field,$fieldDefinition))
			#if ($field.getName())
				#set($aName = $utility.firstToLowerCase($field.getName()))
				#set($curType = $field.getName())
			#else
				#set ($aName = $utility.firstToLowerCase($field.getType()))
				#set($curType = $field.getType())
			#end 

			#if ($utility.isArray($curType))
						
				/**
				 * add element of type $utility.arrayBaseType($curType) to $curType .
				 * @param  $utility.arrayBaseType($curType)
				 */
				public void addTo$curType ($utility.arrayBaseType($curType) element) {
					if (this.$aName == null){
						this.$aName = new $curType();
					} 
				 	this.$aName$add (element);
				}
			#end		
		## FieldDefinition
		#else
					//TODO 12 template wrote this - unexpected object $field
		#end	
	#end
  
  

  
	## parameter or choice
	#foreach($field in $parameter.getParameterOrChoice())
		## parameters usually don't have names, so the variable gets the typ with first letter to lower case as name
		## however there are some exceptions to this where there is a name given
		#if ($field.getName())
			#set ($curName = $utility.firstToLowerCase($field.getName()))
		#else
			#set ($curName = $utility.firstToLowerCase($field.getType()))
		#end 
		#if ($field.getRepeat()== $mustListRepeat  || $field.getRepeat()== $optionalListRepeat)
				/**
				 * add element $curName of type $field.getType() .
				 * @param  $curName of type $field.getType() 
				 */
			public void addTo$utility.firstToUpperCase($curName)$list ($field.getType() $curName) {
				if (this.$curName$list == null){
					this.$curName$list = new LinkedList<$field.getType()>();
				} 
			 	this.$curName$list$add ($curName);
			}
				
		#end
	#end
	// end add
## end add	
	
## TV Parameters have type number from 0 - 127, TLV from 128 - 2047
#if ($parameter.getTypeNum() < 128)
## TV Parameters need static length method for decoding
	/**
	* return length of parameter. For TV Parameter it is always length of its field plus 8 bits for type.
	* @return Integer giving length
	*/
	public static Integer length(){
		int tempLength = PARAMETERTYPELENGTH;
		#foreach($field in $parameter.getFieldOrReserved())
			// the length of a TV parameter in bits is always the type 
		#if ($field.getEnumeration())
			#if ($utility.isArray($utility.convertType($field.getType().value())))
					#set ($arr = "Array")
						#set ($temp = "$utility.firstToUpperCase($field.getEnumeration())")
						#set ($curType = "$temp$arr")
					#else
						#set ($curType = $utility.firstToUpperCase($field.getEnumeration()))
					#end
			tempLength += $curType$length;
		#elseif ($field.getFormat())
			#set ($firstF = "$utility.convertType($field.getType().value())")
			#set ($secondF = "_")
			#set ($thirdF = "$field.getFormat()")
			 tempLength += $firstF$secondF$thirdF$length; 
		#else
			tempLength += $utility.convertType($field.getType().value())$length;
		#end			
		#end
		return tempLength;
	}
#else
## these method basically only exists for compile reasons
	/**
	* For TLV Parameter length can not be determined at compile time. This method therefore always returns 0.
	* @return Integer always zero
	*/
	public static Integer length(){
		return 0;
	}
#end

	/**
    * {@inheritDoc}
    */
	public SignedShort getTypeNum() {
		return TYPENUM;
	}
	
	/**
    * {@inheritDoc}
    */
	public String getName() {
		return "$parameter.Name";
	
	}
	
	
		/**
	* return string representation. All field values but no parameters are included
	* @return String
	*/
	public String toString() {
		String result = "$parameter.getName(): ";
		#foreach($field in $parameter.getFieldOrReserved())
			## reserved field
			#if ($utility.hasType($field,$reservedDefinition))
				
			#elseif ($utility.hasType($field,$fieldDefinition))
					result += ", $utility.firstToLowerCase($field.getName()): ";
					result += $utility.firstToLowerCase($field.getName());
			#else
						//TODO 2 template wrote this - unexpected object $field
			#end	
		#end
		result = result.replaceFirst(", ", "");
		return result;
	}
	
## end of Class	
}




	