## javaEnumerationTemplate.vm	
/*
 *
 * This file was generated by LLRP Code Generator 
 * see http://llrp-toolkit.cvs.sourceforge.net/llrp-toolkit/ 
 * for more information
 * Generated on: $utility.getDateNTime(); 
 *
 */

/*
 * Copyright 2007 ETH Zurich
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 *
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at 
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
 * See the License for the specific language governing permissions and 
 * limitations under the License.
 *
 */

package org.llrp.ltk.generated.enumerations;



	import org.llrp.ltk.types.LLRPBitList;
import org.llrp.ltk.types.$utility.getSuperType($className);
import org.llrp.ltk.types.LLRPEnumeration;
import org.llrp.ltk.types.$utility.getBaseType($superType);
import org.llrp.ltk.generated.LLRPConstants;

			
import org.jdom.Element;
import org.jdom.Text;
import org.jdom.Content;
import org.jdom.Namespace;

import org.apache.log4j.Logger;
import java.math.BigInteger;
import java.lang.IllegalArgumentException;
import java.util.LinkedList;
import java.util.List;


/**
 * $className is Enumeration of Type $utility.getSuperType($className)
 */
public class $className extends $superType implements LLRPEnumeration{
	#set($class = ".class")
	Logger logger = Logger.getLogger($className$class);
	
	
				#foreach ($entry in $enum.getEntry())
					public static final int $entry.getName() = $entry.getValue();
				#end
	
	public $className (){
		super(0);
	}
	
	
	/**
	 * Create new $className by passing integer value.
	 *
	 * @throws IllegalArgumentException
	 * if the value is not allowed for this enumeration
	 * @param value an Integer value allowed - might check first
	 * with isValidValue it it is an allowed value
	 */
	public $className (int	 value){
		## arrays can not be created by calling the integer constructor as this would set the length of the array instead of
		## interpreting it as a value
		#if ($utility.isArray($utility.getSuperType($className)))
			// Enumerations must use String constructor
			        super(new Integer(value).toString());
		#else
			super(value);
		#end
		if (!isValidValue(value)){
			throw new IllegalArgumentException("Value not allowed");
		}
	}
	
	
	#if ($utility.isArray($utility.getSuperType($className)))
	
		/**
		 * Create new $className by passing jdom element.
		 *
		 * @throws IllegalArgumentException
		 * String must be a concatenation of several enumeration strings seperated by whitespace
		 * @param element - jdom element where the child is a string
		 * that contains several names for values of the enumeration.
		 */
		public $className (final Element element){
			String[] items = element.getText().split(" ");
			this.bytes = new $utility.getBaseType($superType)[items.length];
			for (int i = 0; i< items.length;i++){
				this.bytes[i] = new  $utility.getBaseType($superType)(getValue(items[i]));
			}
	}

	#else
		/**
		 * Create new $className by passing jdom element.
		 *
		 * @throws IllegalArgumentException
		 * if the value found in element is not allowed 
		 * for this enumeration.
		 * @param element - jdom element where the child is a string
		 * that is the name for a value of the enumeration.
		 */
		public $className (final Element element){
	        this(element.getText());
		}


	#end	
	
		

	
	
	
	#if ($utility.isArray($utility.getSuperType($className)))
	
		/**
		 * Create new $className by passing a string
		 *
		 * @throws IllegalArgumentException
		 * String must be a concatenation of several enumeration strings seperated by whitespace
		 * @param element - string that contains several names for values of the enumeration.
		 */
		public $className (final String element){
			String[] items = element.split(" ");
			this.bytes = new  $utility.getBaseType($superType)[items.length];
			for (int i = 0; i< items.length;i++){
				this.bytes[i] = new  $utility.getBaseType($superType)(getValue(items[i]));
			}
		}
	#else
		/**
		 * Create new $className by passing a string.
		 *
		 * @throws IllegalArgumentException
		 * if the string does not stand for a valid value.
		 */	
		public $className (final String name){
			if (!isValidName(name)){
				throw new IllegalArgumentException("Name not allowed");
			}
			#if ($utility.getSuperType($className) == "UnsignedInteger")
	        	this.value = BigInteger.valueOf(getValue(name));
	        #else
	        	this.value = getValue(name);
	        #end
			signed = false;			
		}
	#end
	
	
	/**
	 * Create new $className by passing LLRPBitList.
	 *
	 * @throws IllegalArgumentException
	 * if the value found in the BitList is not allowed
	 * for this enumeration.
	 * @param list - LLRPBitList
	 */
	public $className (final LLRPBitList list){
		decodeBinary(list);
		if (!isValidValue(new Integer(toInteger()))){
			throw new IllegalArgumentException("Value not allowed");
		}		
	}
	

	#if ($utility.isArray($utility.getSuperType($className)))
			/**
		 * set a value of this enumeration to the 
		 * value identified by given string.
		 *
		 * @throws IllegalArgumentException
		 * if the value found for given String is not allowed
		 * for this enumeration.
		 * @param name set this enumeration to hold one of the allowed values
		 */
		public final void set(final String name, int position){
			if (!isValidName(name)) throw new IllegalArgumentException("name not allowed");
			if (position > this.bytes.length) throw new IllegalArgumentException("position is bigger than array size");
			bytes[position] = new $utility.getBaseType($superType)(getValue(name));
		}
		
		/** 
		* if no position is provided, the first element is set
		**/
		public final void set(final String name){
			set(name, 0);
		}
	#else
		/**
		 * set the current value of this enumeration to the 
		 * value identified by given string.
		 *
		 * @throws IllegalArgumentException
		 * if the value found for given String is not allowed
		 * for this enumeration.
		 * @param name set this enumeration to hold one of the allowed values
		 */
		public final void set(final String name){
			if (!isValidName(name)) throw new IllegalArgumentException("name not allowed");
			#if ($utility.getSuperType($className) == "UnsignedInteger")
	        	this.value = BigInteger.valueOf(getValue(name));
	        #else
	        	this.value = getValue(name);
	        #end
		}
	#end



	#if ($utility.isArray($utility.getSuperType($className)))
	
	
				/**
		 * set a value of this enumeration to the 
		 * value identified by given string.
		 *
		 * @throws IllegalArgumentException
		 * if the value found for given String is not allowed
		 * for this enumeration.
		 * @param value to be set at position
		 */
		public final void set(final int value, int position){
			if (!isValidValue(value)) throw new IllegalArgumentException("name not allowed");
			if (position > this.bytes.length) throw new IllegalArgumentException("position is bigger than array size");
			bytes[position] = new  $utility.getBaseType($superType)(value);

		}
		
		/** 
		* if no position is provided, the first element is set
		**/
		public final void set(final int value){
			set(value, 0);
		}
		
	#else
		/**
		 * set the current value of this enumeration to the 
		 * value given.
		 *
		 * @throws IllegalArgumentException
		 * if the value is not allowed
		 * for this enumeration.
		 * @param value to be set 
		 */	
		public final void set(final int value){
			if (!isValidValue(value)) throw new IllegalArgumentException("value not allowed");
			#if ($utility.getSuperType($className) == "UnsignedInteger")
	        	this.value = BigInteger.valueOf(value);
	        #else
	        	this.value = value;
	        #end
		}
	#end

	/**
		* {@inheritDoc}
	 */	
    public Content encodeXML(final String name, Namespace ns) {
		#set($ns = "NAMESPACE")

        Element element = new Element(name, ns);
    	//Element element = new Element(name, Namespace.getNamespace("$vendor",LLRPConstants.$vendor.toUpperCase()$ns));
    	element.setContent(new Text(toString()));
        return element;
    }
	
	#if ($utility.isArray($utility.getSuperType($className)))
		/**
			* {@inheritDoc}
		 */	
		public String toString(){
			String s = "";
			for ( $utility.getBaseType($superType) b : this.bytes){
				s += " ";
				s += getName(b.toInteger());
			}
			return s.replaceFirst(" ", "");
		}
		
				/**
			* There is no reasonable representation as int
			* return 0
		 */	
	public int intValue() {
		return 0;
	}
	#else
		/**
			* {@inheritDoc}
		 */	
		public String toString(){
			return getName(toInteger());
		}
	#end


	/**
		* {@inheritDoc}
	 */	
		public boolean isValidValue(final int value){
			switch (value){
				#foreach ($entry in $enum.getEntry())
				case $entry.getValue(): return true;
				#end
				default: return false;
			}
		}

		
		
	/**
		* {@inheritDoc}
	 */		
		public final int getValue(final String name){
				#foreach ($entry in $enum.getEntry())
					if ( name.equalsIgnoreCase("$entry.getName()") ) return $entry.getValue();
				#end
				return -1;
		}
		
    /**
             * {@inheritDoc}
     */
    public final String getName(final int value) {
			#foreach ($entry in $enum.getEntry())
				if ($entry.getValue() == value ) return "$entry.getName()";
			#end
			return "";
		}
		
		/**
		 	* {@inheritDoc}
		 */	
		public boolean isValidName(final String name){
			#foreach ($entry in $enum.getEntry())
				if (name.equals("$entry.getName()") ) return true;
			#end
			return false;
		}
		
	 
		
		    /**
     * number of bits used to represent this type.
     *
     * @return Integer
     */
    public static int length() {
    	#set($length = ".length()")
        return $utility.getSuperType($className)$length; 
    }
    
       /**
             * wrapper method for UnsignedIntegers that use BigIntegers to store value
    * 
     */
    private final String getName(final BigInteger value) {
			logger.warn("$className must convert BigInteger "+value+" to Integer value "+value.intValue());
			return getName(value.intValue());
		}
		
		       /**
             * wrapper method for UnsignedIntegers that use BigIntegers to store value
    * 
     */
    private final boolean isValidValue(final BigInteger value) {
			logger.warn("$className must convert BigInteger "+value+" to Integer value "+value.intValue());
			return isValidValue(value.intValue());
		}
}
