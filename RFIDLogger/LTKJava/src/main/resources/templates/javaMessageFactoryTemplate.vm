/*
 *
 * This file was generated by LLRP Code Generator 
 * see http://llrp-toolkit.cvs.sourceforge.net/llrp-toolkit/ for more information
 * Generated on: $utility.getDateNTime(); 
 *
 */

/*
 *  Copyright 2007 Pramari, LLC.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
*/

package org.llrp.ltk.generated;

import org.apache.log4j.Logger;
import org.jdom.Document;
import org.jdom.Element;
import java.util.HashMap;
import org.llrp.ltk.types.*;
import org.llrp.ltk.exceptions.InvalidLLRPMessageException;
import org.llrp.ltk.generated.messages.*;
#if (!$customs.isEmpty())
	import org.llrp.ltk.generated.custom.messages.*;
#end
/**
 * 
 * LLRPMessageFactory generates LLRPMessage objects from LLRP Messages
 * in binary or LTK XML encoding.
 *
 * LLRPMessageFactory detects the message types in a binary or XML message and 
 * instantiates the corresponding LTK Java message object, e.g. ADD_ROSPEC. 
 * The static factory methods return the abstract LLRPMessage.
 * 
 * Example: Input a LLRP message in LTK XML format and output the binary 
 * representation:
 * 
 * // build JDOM document from file
 * org.jdom.Document doc = new org.jdom.input.SAXBuilder().build(new
 *						FileReader(filename));
 * // create LTK-Java object			
 * LLRPMessage message = LLRPMessageFactory.createLLRPMessage(doc);
 * 
 * // output as a binary message
 * byte[] output = message.encodeBinary();
 * 
 *
 *
 * @author Andreas Huebner - andreas@pramari.com
 * @author Christian Floerkemeier - floerkem@mit.edu
 *
 */
public class LLRPMessageFactory {

	/* logger for LLRPMessageFactory */
	private static final Logger logger = Logger.getLogger("LLRPMessageFactory");

	public static final int reservedLength = 3;
	public static final int versionLength = 3;

	/**
	 * Generates a LLRPMessage out of the given LLRPBitList. 
	 * 
	 * @param bits
	 * 	LLRPBitList of a LLRPMessage
	 * @return appropriate LLRPMessage out of the given LLRPBitList
	 * 		   or null when Message couldn't be generated
	 */
	public static LLRPMessage createLLRPMessage(LLRPBitList bits) throws InvalidLLRPMessageException {

		// determine messageType
		Short messageType = new SignedShort(bits.subList(reservedLength
				+ versionLength, SignedShort.length()
				- (reservedLength + versionLength))).toShort();

		LLRPMessage message = null;
		
		// construct appropriate message object
		#foreach($message in $messages)
		    #set($typenumString = ".TYPENUM.intValue()")
			if(messageType == $message.getName()$typenumString){
					message = new $message.getName()(bits);
					#set($subtypeString = ".subtype.intValue()")
					#if ($message.getName() == "CUSTOM_MESSAGE")
				        int subtype = ((CUSTOM_MESSAGE) message).getMessageSubtype().intValue();
						#foreach($custom in $customs)
				            if (subtype == $custom.getName()$subtypeString){
            					message = new $custom.getName()(bits);
            				}
						#end
						// end custom
					#end
					
			}
		#end

		// check whether the message type exists
		if(message == null){
		    throw new InvalidLLRPMessageException("The message type (\"" + messageType + "\") specified in the binary LLRP message is not known.");
		}
		else {
			return message;
		}
	}

	/**
	 * Generates a LLRPMessage out of the given Byte Array.
	 * 
	 * @param byteArray
	 * 	byte[] of a LLRPMessage
	 * @return appropriate LLRPMessage out of the given byte[]
	 * 		   or null when Message couldn't be generated
	 */
	public static LLRPMessage createLLRPMessage(byte[] byteArray) throws InvalidLLRPMessageException {

		LLRPBitList bits = new LLRPBitList(byteArray);

		return createLLRPMessage(bits);
	}

	public static LLRPMessage createLLRPMessage(Document document) throws InvalidLLRPMessageException {

		// determine messageType
		Element root = document.getRootElement();
		String className = root.getName();
		logger.debug("Root element of input document is: " + className);

		// construct appropriate message object
		LLRPMessage message = null;

		#foreach($message in $messages)
		
		if(className.equals("$message.getName()")){
					message = new $message.getName()(document);
					
		}
		#end
		
		#foreach($custom in $customs)
		
		if(className.equals("$custom.getName()")){
				    message = new $custom.getName()(document);
        
        }    				
		#end
		
		// check whether the message type exists
		if(message == null){
		    throw new InvalidLLRPMessageException("The message type (\"" + className + "\") specified in the LTK-XML message is not known.");
		}
		else {
			return message;
		}

	}
}